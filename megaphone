#!/usr/bin/env python
import json
import sys
import os
from bottle import route, run, get, abort, post, request
import time
import urllib2, urllib
import shutil

t = time.localtime()
ts = time.strftime('%Y-%m-%dT%H:%M:%S%Z', t)

# Change working directory so relative paths (and template lookup) work again
root = os.path.join(os.path.dirname(__file__))
sys.path.insert(0, root)

# this should be a dynamic list:
cache = "/Users/dsl/code/bottle/Megaphone/cache.json"
if os.path.isfile(cache) == True:
	with open(cache) as data_file:    
    		services = json.load(data_file)
else:
	services = {}

def writecache(data):
	try:
		if os.path.isfile(cache) == True:
			backup = "%s.backup" % cache
			print "INFO: backing up cache"
			shutil.copyfile(cache, backup)
		print "INFO: creating new cache"
		with open(cache, 'w') as outfile:
           		json.dump(services, outfile)
	except:
		print "ERROR: cache creation failed!"

# generate nested python dictionaries, copied from here:
# http://stackoverflow.com/questions/635483/what-is-the-best-way-to-implement-nested-dictionaries-in-python
class AutoVivification(dict):
        """Implementation of perl's autovivification feature."""
        def __getitem__(self, item):
                try:
                        return dict.__getitem__(self, item)
                except KeyError:
                        value = self[item] = type(self)()
                        return value

def readfile(fname):
    try:
            f = open(fname, 'r')
            o = f.read()
            return re.sub(r'\0',' ',o)
            f.close()
    except:
        msg = "Critical: reading %s failed!" % fname
        return msg

def readstatus(url):
        try:   
		data = json.load(urllib2.urlopen(url))
                return data
        except:
	        pdata = AutoVivification()
		#pdata = {}
                pdata['status'] = "Critical"
                pdata['date'] = ts
		msg = "Unable to communicate with %s!" % url
                pdata['message'] = msg
		return pdata

@get('/service/list')
def list():
	data = AutoVivification()
	return services

@post('/service/add')
def add_submit():
        data = request.body.readline()
        if not data:
                abort(400, 'No data received')
        entity = json.loads(data)
        if not entity.has_key('name'):
                abort(400, 'No name specified')
        try:
		services[entity["name"]] = entity["url"]
		writecache(services)
        except:
                #except ValidationError as ve:
                #abort(400, str(ve))
                abort(400, "ouch")

@post('/service/del')
def delservice():
        data = request.body.readline()
        if not data:
                abort(400, 'No data received')
        entity = json.loads(data)
        if not entity.has_key('name'):
                abort(409, 'No name specified')
        try:
		del services[entity["name"]]
                writecache(services)
        except:
                abort(400, "ouch")

@get('/service/show/:s')
def service(s):
	#data = AutoVivification()
	#data = readstatus(services[s])
	return readstatus(services[s])
	#return data

@get('/status')
def status():
	data = AutoVivification()
	# trying to conform to current monitoring status guidelines
	# http://nagiosplug.sourceforge.net/developer-guidelines.html#PLUGOUTPUT
	statusc = {
	"Warning":  0,
	"Critical":  0,
	"Unknown":  0,
	}
	E = 0
	msg = ""
	for i in services.keys():
		# for all services we're monitoring, capture the state and the message
		# figure out something to do with date testing
		# like throw an error if current date is > 5min from returned date
		x = readstatus(services[i])
		if x['status'] == "Warning":
			statusc['Warning'] = statusc['Warning'] + 1
			msg += "%s:%s:%s|" % (i,x['status'],x['message'])
		elif x['status'] == "Critical":
			statusc['Critical'] = statusc['Critical'] + 1
			msg += "%s:%s:%s|" % (i,x['status'],x['message'])
		elif x['status'] == "OK":
			# Throw it away
			throwaway = "ok"
                else:
			# things aren't Warning, Critical, or OK so something else is going on
                        statusc['Unknown'] = statusc['Unknown'] + 1
			msg += "%s:%s:%s|" % (i,x['status'],x['message'])

	# set the status to the most critical value in the order: Unknown, Warning, Critical
	# i.e. if WARNING is the worst issue, i present that, but if ERROR and WARNING are both present use ERROR
	if statusc['Unknown'] > 0:
		data['status'] = "Unknown"
		E = 1
	if statusc['Warning'] > 0:
		data['status'] = "Warning"
		E = 1
	if statusc['Critical'] > 0:
		data['status'] = "Critical"
		E = 1
	
	# trim the value of msg since we're appending and adding ';' at the end for errors
	if E > 0:
        	data['message'] = msg[:-1]
	else:
		if len(services.keys()) > 0:
			# we didn't find any error states, so we're OK
                	data['status'] = "OK"
                	data['message'] = "Everything is OK!"
		else:
			data['status'] = "Unknown"
                	data['message'] = "No services are registered!"
	data['date'] = ts
	return data
		

run(host='localhost', port=8080, debug=True)
